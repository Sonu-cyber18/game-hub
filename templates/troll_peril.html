<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Troll's Peril - Deceptive Platformer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }
        
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: 'Courier New', monospace;
            color: #e6e6e6;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 10px;
            overflow-x: hidden;
        }
        
        .header {
            text-align: center;
            margin-bottom: 15px;
            width: 100%;
            max-width: 600px;
        }
        
        h1 {
            font-size: 2.2rem;
            margin-bottom: 8px;
            color: #ff3366;
            text-shadow: 0 0 10px rgba(255, 51, 102, 0.5);
            letter-spacing: 2px;
        }
        
        .subtitle {
            color: #4dccff;
            font-size: 1rem;
            margin-bottom: 10px;
        }
        
        .game-container {
            position: relative;
            width: 600px;
            height: 400px;
            border: 3px solid #333;
            border-radius: 8px;
            overflow: hidden;
            background: #0f3460;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            margin-bottom: 15px;
        }
        
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .health-bar {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 150px;
            height: 15px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid #333;
        }
        
        .health-fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #ff3366 0%, #4dccff 100%);
            transition: width 0.3s;
        }
        
        .level-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 6px 12px;
            border-radius: 5px;
            font-size: 1rem;
            border: 2px solid #333;
        }
        
        .start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 52, 96, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            padding: 20px;
            text-align: center;
        }
        
        .start-screen h2 {
            font-size: 2.5rem;
            color: #ff3366;
            margin-bottom: 10px;
            text-shadow: 0 0 15px rgba(255, 51, 102, 0.7);
        }
        
        .start-screen p {
            font-size: 1rem;
            max-width: 500px;
            text-align: center;
            margin-bottom: 20px;
            line-height: 1.5;
        }
        
        .game-title {
            font-size: 3.5rem;
            color: #ff3366;
            text-shadow: 0 0 20px rgba(255, 51, 102, 0.8);
            margin-bottom: 15px;
            letter-spacing: 2px;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        .control-group {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid #333;
        }
        
        .control-group h3 {
            color: #4dccff;
            margin-bottom: 6px;
            font-size: 1rem;
        }
        
        .control-group p {
            font-size: 0.8rem;
            line-height: 1.3;
        }
        
        .key {
            display: inline-block;
            background: #333;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            margin: 0 2px;
            font-weight: bold;
            font-size: 0.8rem;
        }
        
        .hazards-list {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-top: 8px;
            max-width: 600px;
        }
        
        .hazard {
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(0, 0, 0, 0.3);
            padding: 6px 10px;
            border-radius: 5px;
            font-size: 0.8rem;
        }
        
        .hazard-color {
            width: 15px;
            height: 15px;
            border-radius: 3px;
        }
        
        .instructions {
            max-width: 600px;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            border: 1px solid #333;
            font-size: 0.9rem;
        }
        
        .instructions h3 {
            color: #4dccff;
            margin-bottom: 8px;
            font-size: 1.1rem;
        }
        
        .instructions ul {
            padding-left: 20px;
            margin-bottom: 10px;
        }
        
        .instructions li {
            margin-bottom: 6px;
        }
        
        .warning {
            color: #ff3366;
            font-weight: bold;
        }
        
        .death-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            padding: 20px;
            text-align: center;
        }
        
        .death-screen h2 {
            font-size: 2.5rem;
            color: #ff3366;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(255, 51, 102, 0.7);
        }
        
        .death-screen p {
            font-size: 1.1rem;
            margin-bottom: 20px;
            text-align: center;
        }
        
        button {
            background: #4dccff;
            color: #000;
            border: none;
            padding: 10px 20px;
            font-size: 1rem;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            transition: all 0.2s;
            margin: 5px;
        }
        
        button:hover {
            background: #ff3366;
            color: white;
            transform: scale(1.05);
        }
        
        .secret-found {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 5;
            border: 2px solid #4dccff;
            box-shadow: 0 0 20px rgba(77, 204, 255, 0.5);
            max-width: 90%;
        }
        
        .checkpoint-reached {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 15px;
            border-radius: 5px;
            display: none;
            border: 2px solid #4dccff;
            font-size: 0.9rem;
        }
        
        .game-complete {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            padding: 20px;
            text-align: center;
        }
        
        .game-complete h2 {
            font-size: 2.5rem;
            color: #4dccff;
            margin-bottom: 15px;
        }
        
        .button-container {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .start-button {
            font-size: 1.3rem;
            padding: 12px 30px;
            background: linear-gradient(135deg, #4dccff 0%, #ff3366 100%);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .start-button:hover {
            transform: scale(1.1);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
            background: linear-gradient(135deg, #ff3366 0%, #4dccff 100%);
        }
        
        .difficulty-buttons {
            display: flex;
            gap: 8px;
            margin-top: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .difficulty-btn {
            padding: 8px 15px;
            background: rgba(0, 0, 0, 0.5);
            color: #e6e6e6;
            border: 2px solid #333;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
        }
        
        .difficulty-btn:hover {
            background: rgba(77, 204, 255, 0.2);
            border-color: #4dccff;
        }
        
        .difficulty-btn.active {
            background: rgba(255, 51, 102, 0.3);
            border-color: #ff3366;
            color: #ff3366;
        }
        
        .player-tip {
            color: #4dccff;
            font-weight: bold;
            margin-top: 10px;
            font-size: 0.9rem;
        }
        
        @media (max-width: 650px) {
            .game-container, .header, .instructions {
                width: 95%;
            }
            
            .game-container {
                height: 350px;
            }
            
            h1 {
                font-size: 1.8rem;
            }
            
            .game-title {
                font-size: 2.5rem;
            }
            
            .start-screen h2 {
                font-size: 2rem;
            }
            
            .controls {
                gap: 10px;
            }
            
            .control-group {
                padding: 8px 12px;
            }
        }
        
        @media (max-width: 480px) {
            .game-container {
                height: 300px;
            }
            
            .game-title {
                font-size: 2rem;
            }
            
            .start-screen h2 {
                font-size: 1.8rem;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .button-container {
                flex-direction: column;
                align-items: center;
            }
            
            button {
                width: 200px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>TROLL'S PERIL</h1>
        <p class="subtitle">A simple-looking platformer filled with deceptive traps</p>
    </div>
    
    <div class="game-container">
        <canvas id="gameCanvas" width="600" height="400"></canvas>
        
        <div class="ui-overlay">
            <div class="health-bar">
                <div class="health-fill" id="healthFill"></div>
            </div>
            <div class="level-info">
                Level: <span id="levelDisplay">1</span> | Deaths: <span id="deathCount">0</span>
            </div>
        </div>
        
        <!-- Start Screen -->
        <div class="start-screen" id="startScreen">
            <div class="game-title">TROLL'S PERIL</div>
            <h2>READY TO BE TROLLED?</h2>
            <p>This looks like a simple platformer, but it's filled with hidden traps, disappearing platforms, and unexpected hazards. The player is the blue character - keep an eye on them!</p>
            
            <div class="difficulty-buttons">
                <button class="difficulty-btn active" id="easyBtn">Easy</button>
                <button class="difficulty-btn" id="normalBtn">Normal</button>
                <button class="difficulty-btn" id="hardBtn">Hard</button>
            </div>
            
            <button class="start-button" id="startButton">START GAME</button>
            <p class="player-tip">Player: Blue character with white eyes</p>
            <p style="margin-top: 10px; font-size: 0.8rem; color: #ffcc00;">Warning: This game is designed to be frustrating!</p>
        </div>
        
        <!-- Death Screen -->
        <div class="death-screen" id="deathScreen">
            <h2>YOU DIED!</h2>
            <p id="deathMessage">The game trolled you!</p>
            <div class="button-container">
                <button id="respawnButton">Respawn at Checkpoint</button>
                <button id="restartButton">Restart Level</button>
            </div>
        </div>
        
        <!-- Secret Found Screen -->
        <div class="secret-found" id="secretFound">
            <h3>SECRET PATH DISCOVERED!</h3>
            <p>You found a hidden route with fewer traps!</p>
            <button id="closeSecret">Continue</button>
        </div>
        
        <!-- Checkpoint Reached -->
        <div class="checkpoint-reached" id="checkpointReached">
            Checkpoint reached! Progress saved.
        </div>
        
        <!-- Level Complete Screen -->
        <div class="game-complete" id="gameComplete">
            <h2>LEVEL COMPLETE!</h2>
            <p>You survived the troll traps and reached the end!</p>
            <div class="button-container">
                <button id="nextLevel">Next Level</button>
                <button id="menuButton">Back to Menu</button>
            </div>
        </div>
    </div>
    
    <div class="controls">
        <div class="control-group">
            <h3>MOVEMENT</h3>
            <p><span class="key">A</span> / <span class="key">←</span> Move Left</p>
            <p><span class="key">D</span> / <span class="key">→</span> Move Right</p>
            <p><span class="key">SPACE</span> / <span class="key">W</span> / <span class="key">↑</span> Jump</p>
        </div>
        
        <div class="control-group">
            <h3>HAZARDS</h3>
            <p>Memorize patterns to survive!</p>
            <p>Watch for disappearing platforms</p>
        </div>
        
        <div class="control-group">
            <h3>DIFFICULTY</h3>
            <p>Easy: Fewer traps</p>
            <p>Normal: Standard</p>
            <p>Hard: Maximum troll</p>
        </div>
    </div>
    
    <div class="hazards-list">
        <div class="hazard">
            <div class="hazard-color" style="background: #ff3366;"></div>
            <span>Spikes - Instant death</span>
        </div>
        <div class="hazard">
            <div class="hazard-color" style="background: #ffcc00;"></div>
            <span>Disappearing platforms</span>
        </div>
        <div class="hazard">
            <div class="hazard-color" style="background: #9933ff;"></div>
            <span>Fake platforms</span>
        </div>
        <div class="hazard">
            <div class="hazard-color" style="background: #33cc33;"></div>
            <span>Moving platforms</span>
        </div>
        <div class="hazard">
            <div class="hazard-color" style="background: #4dccff;"></div>
            <span>Checkpoints</span>
        </div>
    </div>
    
    <div class="instructions">
        <h3>GAME MECHANICS & WARNING</h3>
        <ul>
            <li><span class="warning">PLAYER:</span> Blue character with white eyes. Keep them safe!</li>
            <li>Platforms with <span class="warning">yellow outlines</span> disappear after being stepped on</li>
            <li><span class="warning">Purple platforms</span> are fake and will drop you through</li>
            <li>Spikes pop out unexpectedly from walls and ceilings</li>
            <li>Some blocks will fall instantly when you walk under them</li>
            <li>Look for hidden paths that bypass difficult sections</li>
            <li>Checkpoints save your progress - look for floating blue crystals</li>
        </ul>
        <p class="warning">This game is designed to troll you. Expect unfair traps and deceptive mechanics!</p>
    </div>

    <script>
        // Game variables
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // UI Elements
        const startScreen = document.getElementById('startScreen');
        const startButton = document.getElementById('startButton');
        const deathScreen = document.getElementById('deathScreen');
        const deathMessage = document.getElementById('deathMessage');
        const respawnButton = document.getElementById('respawnButton');
        const restartButton = document.getElementById('restartButton');
        const healthFill = document.getElementById('healthFill');
        const levelDisplay = document.getElementById('levelDisplay');
        const deathCount = document.getElementById('deathCount');
        const secretFound = document.getElementById('secretFound');
        const closeSecret = document.getElementById('closeSecret');
        const checkpointReached = document.getElementById('checkpointReached');
        const gameComplete = document.getElementById('gameComplete');
        const nextLevelButton = document.getElementById('nextLevel');
        const menuButton = document.getElementById('menuButton');
        
        // Difficulty buttons
        const easyBtn = document.getElementById('easyBtn');
        const normalBtn = document.getElementById('normalBtn');
        const hardBtn = document.getElementById('hardBtn');
        
        // Game state
        let gameState = {
            player: {
                x: 50,
                y: 300,
                width: 20,  // Made smaller for better visibility
                height: 30, // Made smaller for better visibility
                velocityX: 0,
                velocityY: 0,
                speed: 4,
                jumpForce: 12,
                isOnGround: false,
                health: 100,
                maxHealth: 100,
                color: '#4dccff'
            },
            level: 1,
            deaths: 0,
            difficulty: 'normal',
            checkpoints: [],
            currentCheckpoint: 0,
            platforms: [],
            hazards: [],
            movingPlatforms: [],
            fallingBlocks: [],
            traps: [],
            secretPaths: [],
            isJumping: false,
            keys: {},
            gameOver: false,
            levelComplete: false,
            gameStarted: false,
            secretFoundCount: 0,
            cameraX: 0
        };
        
        // Death messages
        const deathMessages = [
            "The floor betrayed you!",
            "Spikes came out of nowhere!",
            "That platform was fake!",
            "You should have seen that coming!",
            "The game trolled you!",
            "That was predictable... or was it?",
            "You fell for a classic trap!",
            "A block fell on your head!",
            "You walked right into that one!",
            "Didn't see that coming, did you?"
        ];
        
        // Initialize the game
        function initGame() {
            gameState.platforms = [];
            gameState.hazards = [];
            gameState.movingPlatforms = [];
            gameState.fallingBlocks = [];
            gameState.traps = [];
            gameState.secretPaths = [];
            gameState.checkpoints = [];
            gameState.currentCheckpoint = 0;
            gameState.cameraX = 0;
            
            // Reset player
            gameState.player.health = gameState.player.maxHealth;
            gameState.player.x = 50;
            gameState.player.y = 300;
            gameState.player.velocityX = 0;
            gameState.player.velocityY = 0;
            
            // Create level
            createLevel(gameState.level);
            
            // Update UI
            healthFill.style.width = '100%';
            levelDisplay.textContent = gameState.level;
            deathCount.textContent = gameState.deaths;
            
            // Hide screens
            deathScreen.style.display = 'none';
            gameComplete.style.display = 'none';
            gameState.gameOver = false;
            gameState.levelComplete = false;
        }
        
        // Create level elements - scaled for smaller canvas
        function createLevel(level) {
            // Base platforms - scaled for 600x400 canvas
            gameState.platforms = [
                // Ground
                {x: 0, y: canvas.height - 30, width: canvas.width * 2, height: 30, color: '#333'},
                
                // Starting platform
                {x: 0, y: 290, width: 100, height: 15, color: '#555'},
                
                // Platform sequence
                {x: 130, y: 260, width: 70, height: 12, color: '#555'},
                {x: 230, y: 230, width: 70, height: 12, color: '#555'},
                {x: 330, y: 200, width: 70, height: 12, color: '#555'},
                
                // Disappearing platforms (yellow)
                {x: 180, y: 180, width: 50, height: 10, color: '#ffcc00', disappears: true, active: true},
                {x: 280, y: 150, width: 50, height: 10, color: '#ffcc00', disappears: true, active: true},
                {x: 380, y: 120, width: 50, height: 10, color: '#ffcc00', disappears: true, active: true},
                
                // Fake platforms (purple)
                {x: 450, y: 220, width: 60, height: 12, color: '#9933ff', fake: true},
                {x: 530, y: 190, width: 60, height: 12, color: '#9933ff', fake: true},
                
                // Final platform
                {x: 550, y: 130, width: 70, height: 15, color: '#555'},
            ];
            
            // Adjust difficulty
            adjustDifficulty();
            
            // Add more for higher levels
            if (level > 1) {
                gameState.platforms.push(
                    {x: 80, y: 100, width: 60, height: 10, color: '#555'},
                    {x: 200, y: 70, width: 60, height: 10, color: '#555'},
                    {x: 400, y: 50, width: 60, height: 10, color: '#555'}
                );
            }
            
            // Moving platforms
            gameState.movingPlatforms = [
                {x: 120, y: 100, width: 70, height: 10, color: '#33cc33', speed: 1.5, direction: 1, minX: 120, maxX: 250},
                {x: 320, y: 60, width: 70, height: 10, color: '#33cc33', speed: 1.2, direction: 1, minX: 320, maxX: 500}
            ];
            
            // Hazards - scaled down
            gameState.hazards = [
                // Floor spikes
                {x: 280, y: canvas.height - 50, width: 25, height: 15, color: '#ff3366', type: 'spike'},
                {x: 400, y: canvas.height - 50, width: 25, height: 15, color: '#ff3366', type: 'spike'},
                {x: 520, y: canvas.height - 50, width: 25, height: 15, color: '#ff3366', type: 'spike'},
                
                // Wall spikes
                {x: 200, y: 200, width: 15, height: 25, color: '#ff3366', type: 'spike', hidden: Math.random() > 0.5},
                {x: 380, y: 130, width: 15, height: 25, color: '#ff3366', type: 'spike', hidden: Math.random() > 0.5},
                {x: 500, y: 80, width: 15, height: 25, color: '#ff3366', type: 'spike', hidden: Math.random() > 0.5},
            ];
            
            // Adjust hazards based on difficulty
            if (gameState.difficulty === 'easy') {
                gameState.hazards = gameState.hazards.slice(0, 3);
            } else if (gameState.difficulty === 'hard') {
                gameState.hazards.push(
                    {x: 100, y: canvas.height - 50, width: 25, height: 15, color: '#ff3366', type: 'spike'},
                    {x: 160, y: 250, width: 15, height: 25, color: '#ff3366', type: 'spike', hidden: Math.random() > 0.3}
                );
            }
            
            // Falling blocks - scaled down
            gameState.fallingBlocks = [
                {x: 250, y: 0, width: 35, height: 35, color: '#888', falling: false, fallSpeed: 6, triggered: false},
                {x: 450, y: 0, width: 35, height: 35, color: '#888', falling: false, fallSpeed: 6, triggered: false}
            ];
            
            // Traps
            gameState.traps = [
                {x: 230, y: 220, width: 35, height: 8, type: 'spikeTrap', activated: false},
                {x: 430, y: 120, width: 35, height: 8, type: 'spikeTrap', activated: false},
                {x: 550, y: 160, width: 35, height: 8, type: 'fallingBlock', activated: false}
            ];
            
            // Checkpoints - scaled down
            gameState.checkpoints = [
                {x: 160, y: 150, width: 18, height: 25, color: '#4dccff'},
                {x: 420, y: 50, width: 18, height: 25, color: '#4dccff'}
            ];
            
            // Secret paths
            gameState.secretPaths = [
                {x: 150, y: 70, width: 100, height: 8, color: '#4dccff', hidden: true},
                {x: 380, y: 20, width: 100, height: 8, color: '#4dccff', hidden: true}
            ];
            
            // Goal
            gameState.goal = {x: 580, y: 100, width: 35, height: 50, color: '#33cc33'};
        }
        
        // Adjust difficulty
        function adjustDifficulty() {
            gameState.platforms.forEach(platform => {
                if (platform.disappears) {
                    if (gameState.difficulty === 'easy') {
                        platform.disappearDelay = 600;
                    } else if (gameState.difficulty === 'hard') {
                        platform.disappearDelay = 150;
                    } else {
                        platform.disappearDelay = 350;
                    }
                }
                
                if (gameState.difficulty === 'hard' && Math.random() > 0.7 && !platform.disappears) {
                    if (platform.color === '#555' && platform.y < 300) {
                        platform.fake = true;
                        platform.color = '#9933ff';
                    }
                }
            });
            
            if (gameState.difficulty === 'hard') {
                gameState.player.jumpForce = 10;
            } else {
                gameState.player.jumpForce = 12;
            }
        }
        
        // Update camera to follow player
        function updateCamera() {
            // Center camera on player
            gameState.cameraX = gameState.player.x - canvas.width / 2 + gameState.player.width / 2;
            
            // Keep camera within bounds
            if (gameState.cameraX < 0) gameState.cameraX = 0;
            if (gameState.cameraX > canvas.width * 2 - canvas.width) {
                gameState.cameraX = canvas.width * 2 - canvas.width;
            }
        }
        
        // Draw with camera offset
        function draw() {
            // Clear canvas
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#0f3460');
            gradient.addColorStop(1, '#1a1a2e');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Save context for camera translation
            ctx.save();
            ctx.translate(-gameState.cameraX, 0);
            
            // Draw platforms
            gameState.platforms.forEach(platform => {
                // Only draw if in view
                if (platform.x + platform.width > gameState.cameraX && platform.x < gameState.cameraX + canvas.width) {
                    ctx.fillStyle = platform.color;
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                    
                    if (platform.disappears) {
                        ctx.strokeStyle = '#ffcc00';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(platform.x, platform.y, platform.width, platform.height);
                        
                        if (platform.active) {
                            const alpha = 0.5 + 0.5 * Math.sin(Date.now() / 300);
                            ctx.fillStyle = `rgba(255, 204, 0, ${alpha * 0.3})`;
                            ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                        }
                    }
                    
                    if (platform.fake) {
                        ctx.fillStyle = 'rgba(153, 51, 255, 0.7)';
                        for (let i = 0; i < platform.width; i += 8) {
                            ctx.fillRect(platform.x + i, platform.y, 4, platform.height);
                        }
                    }
                }
            });
            
            // Draw moving platforms
            gameState.movingPlatforms.forEach(platform => {
                if (platform.x + platform.width > gameState.cameraX && platform.x < gameState.cameraX + canvas.width) {
                    ctx.fillStyle = platform.color;
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                    
                    platform.x += platform.speed * platform.direction;
                    if (platform.x <= platform.minX || platform.x + platform.width >= platform.maxX) {
                        platform.direction *= -1;
                    }
                }
            });
            
            // Draw hazards
            gameState.hazards.forEach(hazard => {
                if (!hazard.hidden && hazard.x + hazard.width > gameState.cameraX && hazard.x < gameState.cameraX + canvas.width) {
                    ctx.fillStyle = hazard.color;
                    ctx.fillRect(hazard.x, hazard.y, hazard.width, hazard.height);
                    
                    ctx.fillStyle = '#cc0033';
                    if (hazard.width > hazard.height) {
                        const spikeWidth = hazard.width / 3;
                        for (let i = 0; i < 3; i++) {
                            ctx.beginPath();
                            ctx.moveTo(hazard.x + i * spikeWidth, hazard.y + hazard.height);
                            ctx.lineTo(hazard.x + i * spikeWidth + spikeWidth/2, hazard.y);
                            ctx.lineTo(hazard.x + (i+1) * spikeWidth, hazard.y + hazard.height);
                            ctx.closePath();
                            ctx.fill();
                        }
                    } else {
                        const spikeHeight = hazard.height / 3;
                        for (let i = 0; i < 3; i++) {
                            ctx.beginPath();
                            ctx.moveTo(hazard.x, hazard.y + i * spikeHeight);
                            ctx.lineTo(hazard.x + hazard.width, hazard.y + i * spikeHeight + spikeHeight/2);
                            ctx.lineTo(hazard.x, hazard.y + (i+1) * spikeHeight);
                            ctx.closePath();
                            ctx.fill();
                        }
                    }
                }
            });
            
            // Draw falling blocks
            gameState.fallingBlocks.forEach(block => {
                if ((block.falling || !block.triggered) && block.x + block.width > gameState.cameraX && block.x < gameState.cameraX + canvas.width) {
                    ctx.fillStyle = block.color;
                    ctx.fillRect(block.x, block.y, block.width, block.height);
                    
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(block.x + 5, block.y + 5);
                    ctx.lineTo(block.x + block.width - 5, block.y + block.height - 5);
                    ctx.moveTo(block.x + block.width - 5, block.y + 5);
                    ctx.lineTo(block.x + 5, block.y + block.height - 5);
                    ctx.stroke();
                    
                    if (block.falling) {
                        block.y += block.fallSpeed;
                        if (block.y > canvas.height - 30) {
                            block.falling = false;
                            block.y = canvas.height - 30 - block.height;
                        }
                    }
                }
            });
            
            // Draw checkpoints
            gameState.checkpoints.forEach((checkpoint, index) => {
                if (checkpoint.x + checkpoint.width > gameState.cameraX && checkpoint.x < gameState.cameraX + canvas.width) {
                    ctx.fillStyle = checkpoint.color;
                    
                    ctx.beginPath();
                    ctx.moveTo(checkpoint.x + checkpoint.width/2, checkpoint.y);
                    ctx.lineTo(checkpoint.x + checkpoint.width, checkpoint.y + checkpoint.height/3);
                    ctx.lineTo(checkpoint.x + checkpoint.width, checkpoint.y + 2*checkpoint.height/3);
                    ctx.lineTo(checkpoint.x + checkpoint.width/2, checkpoint.y + checkpoint.height);
                    ctx.lineTo(checkpoint.x, checkpoint.y + 2*checkpoint.height/3);
                    ctx.lineTo(checkpoint.x, checkpoint.y + checkpoint.height/3);
                    ctx.closePath();
                    ctx.fill();
                    
                    if (gameState.currentCheckpoint === index) {
                        ctx.shadowColor = checkpoint.color;
                        ctx.shadowBlur = 12;
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    }
                }
            });
            
            // Draw secret paths
            gameState.secretPaths.forEach(path => {
                if (!path.hidden && path.x + path.width > gameState.cameraX && path.x < gameState.cameraX + canvas.width) {
                    ctx.fillStyle = path.color;
                    ctx.fillRect(path.x, path.y, path.width, path.height);
                    
                    const alpha = 0.5 + 0.5 * Math.sin(Date.now() / 300);
                    ctx.fillStyle = `rgba(77, 204, 255, ${alpha})`;
                    ctx.fillRect(path.x, path.y, path.width, path.height);
                }
            });
            
            // Draw goal
            if (gameState.goal.x + gameState.goal.width > gameState.cameraX && gameState.goal.x < gameState.cameraX + canvas.width) {
                ctx.fillStyle = gameState.goal.color;
                ctx.fillRect(gameState.goal.x, gameState.goal.y, gameState.goal.width, gameState.goal.height);
                
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(gameState.goal.x + gameState.goal.width - 8, gameState.goal.y, 4, 30);
                ctx.fillStyle = '#ff3366';
                ctx.beginPath();
                ctx.moveTo(gameState.goal.x + gameState.goal.width - 8, gameState.goal.y);
                ctx.lineTo(gameState.goal.x + gameState.goal.width - 16, gameState.goal.y + 12);
                ctx.lineTo(gameState.goal.x + gameState.goal.width - 8, gameState.goal.y + 24);
                ctx.closePath();
                ctx.fill();
            }
            
            // Draw player with camera offset
            ctx.fillStyle = gameState.player.color;
            ctx.fillRect(
                gameState.player.x, 
                gameState.player.y, 
                gameState.player.width, 
                gameState.player.height
            );
            
            // Draw player eyes
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(gameState.player.x + 4, gameState.player.y + 8, 5, 6);
            ctx.fillRect(gameState.player.x + gameState.player.width - 9, gameState.player.y + 8, 5, 6);
            
            // Draw player pupils
            ctx.fillStyle = '#000000';
            const lookDirection = gameState.player.velocityX > 0 ? 1 : (gameState.player.velocityX < 0 ? -1 : 0);
            ctx.fillRect(gameState.player.x + 5 + lookDirection, gameState.player.y + 10, 2, 3);
            ctx.fillRect(gameState.player.x + gameState.player.width - 8 + lookDirection, gameState.player.y + 10, 2, 3);
            
            // Restore context
            ctx.restore();
        }
        
        // Update game state
        function update() {
            // Apply gravity
            gameState.player.velocityY += 0.6;
            
            // Apply friction
            gameState.player.velocityX *= 0.9;
            
            // Handle keyboard input
            if (gameState.keys['ArrowLeft'] || gameState.keys['a'] || gameState.keys['A']) {
                gameState.player.velocityX = -gameState.player.speed;
            }
            if (gameState.keys['ArrowRight'] || gameState.keys['d'] || gameState.keys['D']) {
                gameState.player.velocityX = gameState.player.speed;
            }
            if ((gameState.keys[' '] || gameState.keys['ArrowUp'] || gameState.keys['w'] || gameState.keys['W']) && gameState.player.isOnGround) {
                gameState.player.velocityY = -gameState.player.jumpForce;
                gameState.player.isOnGround = false;
            }
            
            // Update player position
            gameState.player.x += gameState.player.velocityX;
            gameState.player.y += gameState.player.velocityY;
            
            // Keep player in horizontal bounds
            if (gameState.player.x < 0) gameState.player.x = 0;
            if (gameState.player.x + gameState.player.width > canvas.width * 2) {
                gameState.player.x = canvas.width * 2 - gameState.player.width;
            }
            
            // Reset ground state
            gameState.player.isOnGround = false;
            
            // Check collisions with platforms
            gameState.platforms.forEach(platform => {
                if (checkCollision(gameState.player, platform)) {
                    if (platform.fake) return;
                    
                    if (platform.disappears && platform.active) {
                        platform.active = false;
                        setTimeout(() => {
                            const index = gameState.platforms.indexOf(platform);
                            if (index > -1) {
                                gameState.platforms.splice(index, 1);
                            }
                        }, platform.disappearDelay || 350);
                    }
                    
                    // Collision from top
                    if (gameState.player.velocityY > 0 && 
                        gameState.player.y + gameState.player.height - gameState.player.velocityY <= platform.y) {
                        gameState.player.y = platform.y - gameState.player.height;
                        gameState.player.velocityY = 0;
                        gameState.player.isOnGround = true;
                    }
                    // Collision from bottom
                    else if (gameState.player.velocityY < 0 && 
                             gameState.player.y - gameState.player.velocityY >= platform.y + platform.height) {
                        gameState.player.y = platform.y + platform.height;
                        gameState.player.velocityY = 0;
                    }
                    // Collision from sides
                    else {
                        if (gameState.player.velocityX > 0) {
                            gameState.player.x = platform.x - gameState.player.width;
                        } else if (gameState.player.velocityX < 0) {
                            gameState.player.x = platform.x + platform.width;
                        }
                        gameState.player.velocityX = 0;
                    }
                }
            });
            
            // Check collisions with moving platforms
            gameState.movingPlatforms.forEach(platform => {
                if (checkCollision(gameState.player, platform)) {
                    if (gameState.player.velocityY > 0 && 
                        gameState.player.y + gameState.player.height - gameState.player.velocityY <= platform.y) {
                        gameState.player.y = platform.y - gameState.player.height;
                        gameState.player.velocityY = 0;
                        gameState.player.isOnGround = true;
                        
                        // Move with platform
                        gameState.player.x += platform.speed * platform.direction;
                    }
                }
            });
            
            // Check collisions with hazards
            gameState.hazards.forEach(hazard => {
                if (!hazard.hidden && checkCollision(gameState.player, hazard)) {
                    playerDie(`Spikes came out of nowhere!`);
                }
            });
            
            // Check collisions with falling blocks
            gameState.fallingBlocks.forEach(block => {
                if (block.falling && checkCollision(gameState.player, block)) {
                    playerDie(`A block fell on your head!`);
                }
            });
            
            // Check trap triggers
            gameState.traps.forEach(trap => {
                if (!trap.activated && checkCollision(gameState.player, trap)) {
                    trap.activated = true;
                    
                    if (trap.type === 'spikeTrap') {
                        gameState.hazards.forEach(hazard => {
                            if (hazard.hidden && Math.abs(hazard.x - trap.x) < 80) {
                                hazard.hidden = false;
                            }
                        });
                    } else if (trap.type === 'fallingBlock') {
                        gameState.fallingBlocks.forEach(block => {
                            if (!block.triggered && Math.abs(block.x - trap.x) < 80) {
                                block.triggered = true;
                                block.falling = true;
                            }
                        });
                    }
                }
            });
            
            // Check collisions with checkpoints
            gameState.checkpoints.forEach((checkpoint, index) => {
                if (checkCollision(gameState.player, checkpoint)) {
                    if (gameState.currentCheckpoint !== index) {
                        gameState.currentCheckpoint = index;
                        
                        checkpointReached.style.display = 'block';
                        setTimeout(() => {
                            checkpointReached.style.display = 'none';
                        }, 1500);
                    }
                }
            });
            
            // Check collisions with secret paths
            gameState.secretPaths.forEach(path => {
                if (path.hidden && checkCollision(gameState.player, path)) {
                    path.hidden = false;
                    gameState.secretFoundCount++;
                    
                    secretFound.style.display = 'block';
                }
            });
            
            // Check if player reached goal
            if (checkCollision(gameState.player, gameState.goal)) {
                completeLevel();
            }
            
            // Check if player fell off
            if (gameState.player.y > canvas.height) {
                playerDie(`You fell into the abyss!`);
            }
            
            // Random trap activation based on difficulty
            let randomChance = 0.01;
            if (gameState.difficulty === 'easy') randomChance = 0.005;
            if (gameState.difficulty === 'hard') randomChance = 0.02;
            
            if (Math.random() < randomChance) {
                gameState.hazards.forEach(hazard => {
                    if (hazard.type === 'spike' && Math.random() < 0.3) {
                        hazard.hidden = !hazard.hidden;
                    }
                });
            }
            
            // Update camera
            updateCamera();
        }
        
        // Check collision between two rectangles
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }
        
        // Handle player death
        function playerDie(message) {
            gameState.deaths++;
            deathCount.textContent = gameState.deaths;
            
            const randomMessage = deathMessages[Math.floor(Math.random() * deathMessages.length)];
            deathMessage.textContent = message || randomMessage;
            
            gameState.gameOver = true;
            deathScreen.style.display = 'flex';
        }
        
        // Handle level completion
        function completeLevel() {
            gameState.levelComplete = true;
            gameComplete.style.display = 'flex';
        }
        
        // Start the game
        function startGame() {
            gameState.gameStarted = true;
            startScreen.style.display = 'none';
            initGame();
        }
        
        // Game loop
        function gameLoop() {
            if (gameState.gameStarted && !gameState.gameOver && !gameState.levelComplete) {
                update();
                draw();
            }
            requestAnimationFrame(gameLoop);
        }
        
        // Event listeners for keyboard
        window.addEventListener('keydown', (e) => {
            gameState.keys[e.key] = true;
            
            if (e.key === ' ' && e.target === document.body) {
                e.preventDefault();
            }
        });
        
        window.addEventListener('keyup', (e) => {
            gameState.keys[e.key] = false;
        });
        
        // Button event listeners
        startButton.addEventListener('click', startGame);
        
        // Also allow starting with Enter key
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !gameState.gameStarted) {
                startGame();
            }
        });
        
        respawnButton.addEventListener('click', () => {
            if (gameState.checkpoints[gameState.currentCheckpoint]) {
                const checkpoint = gameState.checkpoints[gameState.currentCheckpoint];
                gameState.player.x = checkpoint.x - 25;
                gameState.player.y = checkpoint.y - 40;
            } else {
                gameState.player.x = 50;
                gameState.player.y = 300;
            }
            
            gameState.player.health = gameState.player.maxHealth;
            healthFill.style.width = '100%';
            gameState.player.velocityX = 0;
            gameState.player.velocityY = 0;
            
            deathScreen.style.display = 'none';
            gameState.gameOver = false;
        });
        
        restartButton.addEventListener('click', () => {
            initGame();
            deathScreen.style.display = 'none';
            gameState.gameOver = false;
        });
        
        closeSecret.addEventListener('click', () => {
            secretFound.style.display = 'none';
        });
        
        nextLevelButton.addEventListener('click', () => {
            gameState.level++;
            initGame();
        });
        
        menuButton.addEventListener('click', () => {
            gameState.gameStarted = false;
            gameComplete.style.display = 'none';
            startScreen.style.display = 'flex';
        });
        
        // Difficulty button event listeners
        easyBtn.addEventListener('click', () => {
            gameState.difficulty = 'easy';
            easyBtn.classList.add('active');
            normalBtn.classList.remove('active');
            hardBtn.classList.remove('active');
        });
        
        normalBtn.addEventListener('click', () => {
            gameState.difficulty = 'normal';
            easyBtn.classList.remove('active');
            normalBtn.classList.add('active');
            hardBtn.classList.remove('active');
        });
        
        hardBtn.addEventListener('click', () => {
            gameState.difficulty = 'hard';
            easyBtn.classList.remove('active');
            normalBtn.classList.remove('active');
            hardBtn.classList.add('active');
        });
        
        // Initialize and start the game loop
        gameLoop();
    </script>
</body>
</html>